<script>
let isUploading = false;
let isOpeningQr = false;
let isModalOpen = false;
let suppressUnloadOnce = false;
let isRedirecting = false;
let lastProofUrl = ''; 
let _tickExpiredHandled = false;

/* ========= CLOUD RUN PROXY =========
   Browser -> Cloud Run -> Apps Script
   Cloud Run injects the secret; browser never sees it.
*/
const PROXY_URL = "https://checkoutproxy-294769499638.asia-southeast1.run.app/apps-script"; // â† your Cloud Run URL

async function proxyPost(payload) {
  const res = await fetch(PROXY_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload || {})
  });
  const ct = res.headers.get("content-type") || "";
  if (ct.includes("application/json")) {
    const data = await res.json();
    if (!res.ok) throw new Error(data?.error || `Proxy ${res.status}`);
    return data;
  } else {
    const text = await res.text();
    if (!res.ok) throw new Error(text || `Proxy ${res.status}`);
    try { return JSON.parse(text); } catch { return { ok: true, raw: text }; }
  }
}

function formatDDMMYYYYHHMM(d = new Date()) {
  return new Intl.DateTimeFormat('en-GB', {
    day: '2-digit', month: '2-digit', year: 'numeric',
    hour: '2-digit', minute: '2-digit', hour12: false
  }).format(d).replace(/\//g, '-').replace(',', '');
}

/* ========= CONFIG ========= */
const ONEMAP_PROXY = 'https://script.google.com/macros/s/AKfycbxI0PMIvEx9qZNyB9KF1S0A_kkiA9TYpXI5hBG36Ys1mbrV35LgCWwGalVzQuaA6G5I/exec';
const PAYNOW_API  = 'https://script.google.com/macros/s/AKfycbwsSpKoO5bM_nEBAhwtiSpo9QZcD8KH3xgO9gaIvh3-_VBQDg0pSzgBwFtHbhep9POi/exec';
const UPLOAD_API  = 'https://script.google.com/macros/s/AKfycbxriS7NptwgUanj7DIRS0SO6_CvbWAr6RgFKt3LetnGcT1RoRIGnkZGvJsDrcR_TwKR/exec';
const EMAIL_PDF_API = 'https://script.google.com/macros/s/AKfycbx5T0U7CoGlJ1-MY8lv5gp8lLchlfXpTBxNRhd-Whg8VS4INsCpOguGakPSpPnOn3sl3g/exec';
/* ===== Inventory reservation API (Apps Script Web App) ===== */
const INVENTORY_API  = 'https://script.google.com/macros/s/AKfycbxXkVLXwPwvEwj6X_ugCQmGJz9HcGyKxsJG2KSMkO9UthlmjNI2hMPlbB8ksr9sX4I/exec';
const DISCOUNTS_API = INVENTORY_API;

/* ========= Reservation/Discount helpers (unchanged) ========= */
function normalizeCart(arr){
  return (arr || []).map(i => {
    const obj = { ...i };
    obj.category    = obj.category    ?? '';
    obj.subcategory = obj.subcategory ?? '';
    return obj;
  });
}
function getCart(){
  try{ const raw = JSON.parse(localStorage.getItem("cart") || "[]"); return Array.isArray(raw)? raw:[]; }
  catch{ return []; }
}
function fmt(n){ return (n ?? 0).toLocaleString('en-SG',{style:'currency', currency:'SGD'}); }
const isPurchasable = i => !i.status && (Number(i.qty ?? i.quantity) || 0) > 0;

async function apiHold(items, userRef){
  return await jsonpFetchB64(INVENTORY_API, 'hold', { items, user_ref: userRef || '' });
}
async function apiCancel(holdId, holdToken, reason){
  if (!holdId || !holdToken) return { ok:true };
  return await jsonpFetchB64(INVENTORY_API, 'cancel', {
    hold_id: holdId,
    hold_token: holdToken,
    reason: reason || ''
  });
}
async function apiConfirm(holdId, holdToken, orderId){
  if (!holdId || !holdToken || !orderId)
    return { ok:false, error:'Missing fields' };
  return await jsonpFetchB64(INVENTORY_API, 'confirm', {
    hold_id: holdId,
    hold_token: holdToken,
    order_id: orderId
  });
}
async function loadDiscountRules(){
  try {
    const res = await jsonpFetchB64(DISCOUNTS_API, 'discounts', {}); 
    if (res && res.ok && res.rules) {
      DISCOUNT_RULES = res.rules;
    } else {
      console.warn('[discounts] Bad response:', res);
    }
  } catch (e) {
    console.warn('[discounts] load failed:', e);
  }
}

/* === SFX helper === */
function playUploadSfx(){
  const a = document.getElementById('uploadSfx');
  if (!a) return;
  try{
    a.pause(); a.currentTime = 0;
    const p = a.play();
    if (p && typeof p.catch === 'function') p.catch(()=>{});
  }catch{}
}

/* Simple JSONP (unchanged) */
function jsonpFetch(baseUrl, params) {
  return new Promise((resolve, reject) => {
    const cb = `pay_cb_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
    const qs = new URLSearchParams({ ...params, callback: cb, _: Date.now() });
    const s = document.createElement('script');
    s.src = `${baseUrl}?${qs.toString()}`;
    const timeout = setTimeout(() => { cleanup(); reject(new Error('PAY_JSONP_TIMEOUT')); }, 15000);
    function cleanup(){ clearTimeout(timeout); delete window[cb]; s.remove(); }
    window[cb] = (data) => { cleanup(); resolve(data); };
    s.onerror = () => { cleanup(); reject(new Error('PAY_JSONP_LOAD_ERROR')); };
    document.head.appendChild(s);
  });
}
function jsonpFetchB64(baseUrl, action, obj) {
  const cb  = `inv_cb_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
  const json= JSON.stringify(obj || {});
  const b64 = btoa(unescape(encodeURIComponent(json)));
  const qs  = new URLSearchParams({ action, payload_b64: b64, callback: cb, _: Date.now() });
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    const timeout = setTimeout(() => { cleanup(); reject(new Error('JSONP_TIMEOUT')); }, 15000);
    function cleanup(){ clearTimeout(timeout); delete window[cb]; s.remove(); }
    window[cb] = (data) => { cleanup(); resolve(data); };
    s.onerror  = () => { cleanup(); reject(new Error('JSONP_LOAD_ERROR')); };
    s.src = `${baseUrl}?${qs.toString()}`;
    document.head.appendChild(s);
  });
}

/* JSONP proxy to OneMap (unchanged) */
function proxyFetch(endpoint, params) {
  return new Promise((resolve, reject) => {
    const cb = `onemap_cb_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;
    const qs = new URLSearchParams({ ...params, endpoint, callback: cb, _: Date.now() });
    const s = document.createElement('script');
    s.src = `${ONEMAP_PROXY}?${qs.toString()}`;
    const timeout = setTimeout(() => { cleanup(); reject(new Error('JSONP_TIMEOUT')); }, 8000);
    function cleanup(){ clearTimeout(timeout); delete window[cb]; s.remove(); }
    window[cb] = (data) => { cleanup(); resolve(data); };
    s.onerror = () => { cleanup(); reject(new Error('JSONP_LOAD_ERROR')); };
    document.head.appendChild(s);
  });
}

/* ========= Shipping from cart (unchanged) ========= */
function getSavedShippingFromCart(){
  const RAW = localStorage.getItem('shippingMethod');
  if (!RAW) return null;
  try {
    const obj = JSON.parse(RAW);
    if (obj && (obj.id || obj.label)) return obj;
  } catch(e) {}
  const id = String(RAW).trim().toLowerCase();
  const LABELS = {
    consolidate:'Consolidate Order â€” $0.00',
    letter:'Letterbox-sized package â€” $3.00',
    s:'S-sized package â€” $3.50',
    m:'M-sized package â€” $4.00',
    l:'L-sized package â€” $5.00',
    xl:'XL-sized package â€” $15.00'
  };
  const FEES = { consolidate:0, letter:3.00, s:3.50, m:4.00, l:5.00, xl:15.00 };
  if (id in FEES) return { id, fee: FEES[id], label: LABELS[id] };
  return null;
}
function applySavedShippingToForm(){
  const saved  = getSavedShippingFromCart();
  const hidden = document.getElementById('fMethod');
  const label  = document.getElementById('fMethodLabel');
  if (saved && saved.id){
    if (hidden) hidden.value = saved.id;
    if (label)  label.value  = saved.label || saved.id;
  } else {
    if (hidden) hidden.value = '';
    if (label)  label.value  = '';
  }
}

function getCartSafe(){
  try { const a = JSON.parse(localStorage.getItem('cart') || '[]'); return Array.isArray(a) ? a : []; }
  catch { return []; }
}
function getShippingSafe(){
  try { return JSON.parse(localStorage.getItem('shippingMethod') || 'null'); }
  catch { return null; }
}
function cartFingerprint(){
  const cart = getCartSafe()
    .filter(isPurchasable)
    .map(i => ({
      name: i.name || '',
      price: Number(i.price || 0),
      qty: Number(i.qty ?? i.quantity ?? 1),
      set: i.set || i.subcategory || '',
      year: i.year || i.release_year || ''
    }));
  const ship = getShippingSafe();
  const discCode = getSavedDiscountCode();
  return JSON.stringify({ cart, shipId: ship?.id || ship?.label || '', discCode });
}

function totalCentsFromText(s){
  const n = Number(String(s).replace(/[^0-9.]/g,''));
  return Math.round((Number.isFinite(n) ? n : 0) * 100);
}

let DISCOUNT_RULES = {};
const DISC_KEY = 'checkout.discountCode';
function getSavedDiscountCode(){
  try { return (localStorage.getItem(DISC_KEY) || '').trim(); } catch { return ''; }
}
function setSavedDiscountCode(code){
  try { if (code) localStorage.setItem(DISC_KEY, code); else localStorage.removeItem(DISC_KEY); } catch {}
}
function computeDiscount(subtotal, ship, codeRaw){
  const code = String(codeRaw || '').trim().toLowerCase();
  const rule = DISCOUNT_RULES[code];
  if (!rule) return { amount: 0, ship, code: '', label: '' };
  if (Number(rule.minSubtotal || 0) > 0 && subtotal < Number(rule.minSubtotal)) {
    return { amount: 0, ship, code: '', label: '' };
  }
  let discountAmt = 0;
  let newShip = ship;
  if (rule.kind === 'percent'){
    discountAmt = +(subtotal * (Number(rule.value||0)/100)).toFixed(2);
  } else if (rule.kind === 'amount'){
    discountAmt = Math.min(Number(rule.value||0), Math.max(0, subtotal));
  } else if (rule.kind === 'ship'){
    newShip = 0;
  }
  const cappedBase = Math.max(0, subtotal + newShip);
  discountAmt = Math.min(discountAmt, cappedBase);
  return { amount: discountAmt, ship: newShip, code, label: rule.label || code.toUpperCase() };
}

/* ====== 15-MINUTE PAYMENT SESSION PERSISTENCE ====== */
const DRAFT_KEY = 'breezy.checkout.draft';
const SESSION_MINUTES = 15;
function getDraft() { try { return JSON.parse(localStorage.getItem(DRAFT_KEY) || 'null'); } catch { return null; } }
function setDraft(obj) { try { localStorage.setItem(DRAFT_KEY, JSON.stringify(obj || null)); } catch {} }
function clearDraft() { try { localStorage.removeItem(DRAFT_KEY); } catch {} }
function now(){ return Date.now(); }
function isExpired(d){ return !d || !d.endTime || (now() >= Number(d.endTime)); }
function remainingMs(d){ return Math.max(0, Number(d.endTime) - now()); }

/* ðŸ‘‡ Changed to go via Cloud Run */
async function notifyExpire(orderId, reason){
  if (!orderId) return;
  try {
    await proxyPost({ action:'expire', orderId, reason: reason || 'TIMEOUT' });
  } catch (e) { console.warn('[expire] failed:', e); }
}

/* ===== Payment timer length (10â€“15 min typical) ===== */
const TIMER_MS = 15 * 60 * 1000;

/* Track order id for tagging upload */
let currentOrderId = null;

/* ========= QR Modal ========= */
let countdown = null, endTime = 0;
function genOrderId(){ const t = Date.now().toString(36).toUpperCase().slice(-6); const r = Math.random().toString(36).toUpperCase().slice(2,6); return `BE-${t}${r}`; }
let qrInstance = null;
function renderQr(text){
  const box = document.getElementById('qrBox');
  if (!box) return;
  box.innerHTML = '';
  qrInstance = new QRCode(box, { text, width: 220, height: 220, correctLevel: QRCode.CorrectLevel.M });
}
function parseCurrencyToNumber(s){
  if (!s) return 0;
  const n = Number(String(s).replace(/[^0-9.]/g,''));
  return Number.isFinite(n) ? n : 0;
}

async function openQrCreateNew(){
  if (countdown) { clearInterval(countdown); countdown = null; }
  endTime = 0;

  const totalText = document.getElementById('sumTotal').textContent;
  const totalNum  = parseCurrencyToNumber(totalText);
  const orderId   = genOrderId();
  currentOrderId  = orderId;

  // 1) Build items to reserve
  const holdItems = buildHoldItemsFromCart();
  const userRef   = (document.getElementById('fEmail')?.value || '').trim();

  // 2) Place reservation
  let holdRes;
  try {
    holdRes = await apiHold(holdItems, userRef);
    console.log('[apiHold result]', holdRes);
  } catch (err) {
    alert('Could not reach the reservation server. Please try again.');
    return;
  }
  if (!holdRes?.ok) {
    const list = holdRes?.lacks || holdRes?.missing || holdRes?.insufficient || holdRes?.items || [];
    const problems = (Array.isArray(list) ? list : []).map(x => {
      const name   = x?.item?.name || 'Item';
      const reason = x?.reason || 'UNAVAILABLE';
      const left   = (typeof x?.available === 'number') ? ` (left: ${x.available})` : '';
      return `â€¢ ${name} â€” ${reason}${left}`;
    }).join('\n');
    alert(problems ? `Some items canâ€™t be reserved:\n\n${problems}\n\nPlease update your cart and try again.`
                   : (holdRes?.error || 'Could not reserve stock. Please review your cart and try again.'));
    return;
  }

  const holdId    = holdRes.hold_id;
  const holdToken = holdRes.hold_token;

  // 3) Generate PayNow QR
  try {
    const res = await jsonpFetch(PAYNOW_API, { endpoint: 'pay', amount: totalNum.toFixed(2), orderId: orderId });
    if (!res || !res.ok || !res.payload) throw new Error(res && res.error || 'PAY_BAD_RESPONSE');

    document.getElementById('qrPayTo').textContent   = res.payToLabel || 'PayNow';
    document.getElementById('qrAmount').textContent  = totalText;
    document.getElementById('qrOrderId').textContent = orderId;
    renderQr(res.payload);

    // 4) Save draft (so modal survives reloads)
    const draft = {
      orderId,
      qrPayload: res.payload,
      endTime: Date.now() + TIMER_MS,
      amountText: totalText,
      payToLabel: res.payToLabel || 'PayNow',
      createdAt: Date.now(),
      cartHash: cartFingerprint(),
      totalCents: totalCentsFromText(totalText),
      holdId,
      holdToken
    };
    setDraft(draft);

    // 5) ðŸ‘‡ Send "reserve" to GAS via Cloud Run proxy
    try {
      const payload = gatherOrderPayload();
      payload.order_id   = orderId;
      payload.expires_at = formatDDMMYYYYHHMM(new Date(Date.now() + TIMER_MS)).replace(/\//g,'-').replace(',', '');
      payload.hold_id    = holdId;
      payload.hold_token = holdToken;
      payload.qr_payload = res.payload;
      payload.action     = 'reserve';
      payload.source     = 'checkout';

      // fire-and-forget (or await if you want to block UX on failure)
      proxyPost(payload).catch(err => console.warn('[reserve via proxy] send failed:', err));
    } catch (e) {
      console.warn('[reserve] payload build failed:', e);
    }

    sessionStorage.setItem('pendingOrder', JSON.stringify({ id: orderId, total: totalText }));

    endTime = Date.now() + TIMER_MS;
    tick();
    countdown = setInterval(tick, 1000);
    document.getElementById('qrModal').hidden = false;
    isModalOpen = true;

    try { history.pushState({qr:true}, '', location.href); } catch {}
  } catch (err) {
    console.error('[PayNow] fetch failed:', err);
    try { await apiCancel(holdId, holdToken, 'PAYNOW_FAIL'); } catch {}
    alert('Sorry, we could not generate the payment QR right now. Please try again.');
  }
}

async function openQr(formData){
  const d = getDraft();
  const currentHash  = cartFingerprint();
  const currentTotal = totalCentsFromText(document.getElementById('sumTotal')?.textContent || '');
  if (d && !isExpired(d)) {
    currentOrderId = d.orderId || currentOrderId;
    if (d.qrPayload) renderQr(d.qrPayload);
    endTime = d.endTime;
    document.getElementById('qrPayTo').textContent   = d.payToLabel || document.getElementById('qrPayTo').textContent || 'PayNow';
    document.getElementById('qrAmount').textContent  = d.amountText || document.getElementById('qrAmount').textContent;
    document.getElementById('qrOrderId').textContent = d.orderId || 'â€”';
    tick();
    if (countdown) clearInterval(countdown);
    countdown = setInterval(tick, 1000);
    document.getElementById('qrModal').hidden = false;
    isModalOpen = true;
    try { history.pushState({qr:true}, '', location.href); } catch {}
    return;
  }
  await openQrCreateNew(formData);
}
function closeQr(){
  document.getElementById('qrModal').hidden = true;
  isModalOpen = false;
  if (countdown) { clearInterval(countdown); countdown = null; }
  endTime = 0;
  const t = document.getElementById('qrTimer');
  if (t) { t.classList.remove('timer-urgent'); t.textContent = mmss(TIMER_MS); }
}
async function confirmAbortAndExit(){
  if (isUploading) { alert('Upload in progressâ€”please wait a moment so we donâ€™t lose your proof.'); return; }
  const ok = window.confirm('Are you sure you want to close this payment window?\n\nIf you havenâ€™t paid yet, youâ€™ll be returned to the store.');
  if (!ok) return;
  closeQr();
  const d = getDraft();
  if (d?.holdId && d?.holdToken) { try { await apiCancel(d.holdId, d.holdToken, 'USER_ABORT'); } catch {} }
  clearDraft();
  window.location.href = 'teststore.html';
}
function mmss(ms){
  const totalSec = Math.max(0, Math.floor(ms / 1000));
  const m = String(Math.floor(totalSec / 60)).padStart(2, '0');
  const s = String(totalSec % 60).padStart(2, '0');
  return `${m}:${s}`;
}
async function tick(){
  const remainMs = Math.max(0, endTime - Date.now());
  const el = document.getElementById('qrTimer');
  if (el) {
    el.textContent = mmss(remainMs);
    const remainSec = Math.floor(remainMs / 1000);
    if (remainSec <= 60) el.classList.add('timer-urgent'); else el.classList.remove('timer-urgent');
  }
  if (remainMs <= 0){
    if (_tickExpiredHandled) return;
    _tickExpiredHandled = true;
    clearInterval(countdown); countdown = null;
    closeQr();
    const d = getDraft();
    try { if (d?.orderId) await notifyExpire(d.orderId, 'TIMEOUT'); } catch {}
    if (d?.holdId && d?.holdToken) { try { await apiCancel(d.holdId, d.holdToken, 'TIMEOUT'); } catch {} }
    clearDraft();
    window.alert('Payment session expired. Please open checkout again to get a new QR.');
    isRedirecting = true;
    try { window.removeEventListener('beforeunload', beforeUnloadHandler); } catch {}
    window.location.replace('teststore.html');
  }
}

/* ========= OneMap postal -> address (unchanged) ========= */
const postalCache = Object.create(null);
try { Object.assign(postalCache, JSON.parse(sessionStorage.getItem('postalCache') || '{}')); } catch {}
function savePostalCache(){ try { sessionStorage.setItem('postalCache', JSON.stringify(postalCache)); } catch {} }
async function fetchSGAddressByPostal(postal) {
  const clean = String(postal || '').replace(/\D/g, '');
  if (clean.length !== 6) throw new Error('INPUT_6_DIGITS');
  if (postalCache[clean]) return postalCache[clean];
  const data = await proxyFetch('elastic', { searchVal: clean, size: '5', returnGeom: 'N', getAddrDetails: 'Y', pageNum: '1' });
  const rows = Array.isArray(data?.results) ? data.results : [];
  const exact = rows.find(r => String(r.POSTAL) === clean) || rows[0];
  if (!exact) throw new Error('POSTAL_NOT_FOUND');
  const { BLK_NO, ROAD_NAME, POSTAL } = exact;
  const addr = { addr1: [BLK_NO, ROAD_NAME].filter(Boolean).join(' '), city: 'Singapore', postal: POSTAL || clean };
  postalCache[clean] = addr; savePostalCache(); return addr;
}
function fillAddressFields(addr){
  const a1 = document.getElementById('fAddr1');
  const city = document.getElementById('fCity');
  const postalEl = document.getElementById('fPostal');
  if (a1) a1.value = addr.addr1 || '';
  if (city) city.value = addr.city || 'Singapore';
  if (postalEl && addr.postal) postalEl.value = addr.postal;
  renderSummary(); syncPayCta();
}

/* ========= Utilities (unchanged) ========= */
function debounce(fn, ms=300){ let t; return (...args)=>{ clearTimeout(t); t = setTimeout(()=>fn(...args), ms); }; }
function parseCurrencyToNumberOrZero(s){ return parseCurrencyToNumber(s); }
function setTouched(el){ if (!el.dataset.touched) el.dataset.touched = '1'; }
function markValidity(el){
  const hasVal = !!el.value;
  const bad = el.validity && !el.validity.valid;
  const showRed = (el.dataset.touched === '1') && bad;
  el.classList.toggle('invalid', !!showRed);
  el.classList.toggle('valid', hasVal && !bad);
}
function renderErrors(){
  const box = document.getElementById('formErrors');
  if (!box) return;
  const msgs = [];
  const ids = ['fName','fEmail','fPhone','fPostal','fAddr1','fUnit','fMethod'];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    if (el.dataset.touched === '1' && el.validity && !el.validity.valid){
      msgs.push(el.validationMessage || 'Please check this field.');
    }
  });
  const agree = document.getElementById('disc1');
  if (agree && agree.dataset.touched === '1' && !agree.checked){
    msgs.push('Please agree that the information above is correct.');
  }
  box.textContent = msgs.join('\n');
}
function clearLocalCartHard() {
  try {
    localStorage.removeItem('cart');
    localStorage.removeItem('shippingMethod');
    setSavedDiscountCode('');
  } catch {}
  try { renderSummary(); } catch {}
  try { window.dispatchEvent(new CustomEvent('cart:cleared')); } catch {}
}

/* ========= Upload (unchanged) ========= */
async function uploadPaymentProofJSON() {
  const paidBtn  = document.getElementById('qrPaid');
  const statusEl = document.getElementById('uploadStatus');
  const fileInput= document.getElementById('proofFile');
  const f = fileInput?.files?.[0] || null;
  const cancelBtn = document.getElementById('qrCancel');
  if (!f) { alert('Please choose a payment screenshot before continuing.'); return false; }
  const okTypes = ['image/jpeg','image/png','image/webp','image/heic','image/heif'];
  if (!okTypes.includes(f.type)) { alert('Please upload a JPG/PNG/WebP/HEIC image.'); return false; }
  if (f.size > 15 * 1024 * 1024) { alert('File too large (max 15 MB).'); return false; }
  paidBtn.disabled = true; cancelBtn.disabled = true; statusEl.textContent = 'Preparing your fileâ€¦';
  const b64 = await new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      try { const dataUrl = reader.result; const comma = dataUrl.indexOf(','); resolve(dataUrl.slice(comma + 1)); }
      catch (e) { reject(e); }
    };
    reader.onerror = reject; reader.readAsDataURL(f);
  });
  const amt = document.getElementById('qrAmount')?.textContent || '';
  const payload = { file_b64: b64, filename: f.name, mimetype: f.type || 'application/octet-stream', note: `Order: ${currentOrderId || 'N/A'} | Amount: ${amt}` };
  isUploading = true; statusEl.textContent = 'Uploading...';
  try {
    const res = await fetch(UPLOAD_API, { method: 'POST', headers: { 'Content-Type': 'text/plain;charset=utf-8' }, body: JSON.stringify(payload) });
    const ct = res.headers.get('content-type') || '';
    if (ct.includes('application/json')) {
      const data = await res.json();
      if (data && (data.ok || data.success)) {
        lastProofUrl = data.proof_url || data.fileUrl || data.url || data.webViewLink || data.webContentLink || lastProofUrl;
        statusEl.textContent = 'Thank you for the wait, your upload is completed âœ“';
        statusEl.classList.add('ok'); statusEl.classList.remove('err'); isUploading = false; return true;
      } else { throw new Error(data?.error || 'Upload failed to reach server'); }
    }
    if (res.ok) {
      statusEl.textContent = 'Thank you for the wait, your upload is completed âœ“';
      statusEl.classList.add('ok'); statusEl.classList.remove('err'); isUploading = false; return true;
    }
    throw new Error('Server returned ' + res.status);
  } catch (errCors) {
    try {
      await fetch(UPLOAD_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), mode: 'no-cors' });
      statusEl.textContent = 'Thank you for the wait, your upload is completed âœ“';
      statusEl.classList.add('ok'); statusEl.classList.remove('err'); isUploading = false; return true;
    } catch (errNoCors) {
      console.error(errNoCors);
      statusEl.textContent = 'Upload failed. Please try again.'; 
      statusEl.classList.add('err'); statusEl.classList.remove('ok');
      paidBtn.disabled = false; cancelBtn.disabled = false; isUploading = false; return false;
    }
  }
}

/* --- Attribute formatting helpers (unchanged) --- */
function escapeHtml(s){
  return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;');
}
function normSeries(obj){ return (obj?.["series name"] || obj?.series || obj?.seriesName || obj?.series_name || "").trim(); }
function formatAttrs(it){
  const series = normSeries(it);
  const set    = (it.subcategory || it.set || it['set name'] || it.set_name || '').trim();
  const year   = (it.year || it.release_year || '').toString().trim();
  const rarity = (it.rarity || '').trim();
  const cond   = (it.condition || '').trim();
  const L = [];
  if (series && set) L.push(`${series}: ${set}`); else if (series) L.push(series); else if (set) L.push(set);
  const R = [year, rarity, cond].filter(Boolean).join(' Â· ');
  return [L.join(''), R ? `- ${R}` : ''].filter(Boolean).join(' ');
}

/* ========= Summary + CTA (unchanged) ========= */
function renderSummary(){
  const itemsEl    = document.getElementById('sumItems');
  const subtotalEl = document.getElementById('sumSubtotal');
  const shippingEl = document.getElementById('sumShipping');
  const totalEl    = document.getElementById('sumTotal');

  // If the summary container(s) aren't in the DOM yet, bail quietly.
  if (!itemsEl || !subtotalEl || !shippingEl || !totalEl) {
    console.warn('[renderSummary] summary elements not found yet â€” skipping this repaint.');
    return;
  }

  const raw  = getCart();
  const cart = raw.filter(isPurchasable);

  const rows = cart.map(i => {
    const qty  = Math.max(1, Number(i.qty ?? i.quantity ?? 1) || 1);
    const unit = Number(i.price ?? 0) || 0;
    const line = unit * qty;
    const name  = i.name || 'Item';
    const attrs = formatAttrs(i);
    return `
      <div class="sum-row">
        <span>
          <div class="sum-item">
            <div class="name">${escapeHtml(name)}${qty > 1 ? ` Ã— ${qty}` : ''}</div>
            ${attrs ? `<div class="attrs">${escapeHtml(attrs)}</div>` : ''}
          </div>
        </span>
        <span class="price">${fmt(line)}</span>
      </div>`;
  }).join('');

  itemsEl.innerHTML = rows || '<div class="hint">No items available to purchase.</div>';

  // base amounts
  const subtotal = cart.reduce((s, i) => {
    const q = Math.max(1, Number(i.qty ?? i.quantity ?? 1) || 1);
    const u = Number(i.price ?? 0) || 0;
    return s + (u * q);
  }, 0);

  const savedShip = getSavedShippingFromCart();
  let ship = Number(savedShip?.fee ?? 0);

  // apply discount
  const code = getSavedDiscountCode();
  const disc = computeDiscount(subtotal, ship, code);
  ship = disc.ship;

  // update rows
  subtotalEl.textContent = fmt(subtotal);
  shippingEl.textContent = fmt(ship);

  const discRow   = document.getElementById('discRowAmount');
  const discTag   = document.getElementById('discCodeTag');
  const discAmtEl = document.getElementById('sumDiscount');

  if (discRow && discAmtEl) {
    if (disc.amount > 0 || code) {
      discRow.hidden = false;
      discAmtEl.textContent = `-${fmt(disc.amount)}`;
      if (discTag) discTag.textContent = code ? `(${(disc.label || code).toString()})` : '';
    } else {
      discRow.hidden = true;
    }
  }

  const total = Math.max(0, subtotal + ship - disc.amount);
  totalEl.textContent = fmt(total);
}

/* Build reservation items from the cart (unchanged) */
function buildHoldItemsFromCart(){
  return getCart().filter(isPurchasable).map(i => ({
    name: String(i.name || 'Item'),
    category: String(i.category || ''),
    subcategory: String(i.subcategory || i.set || ''),
    rarity: String(i.rarity || ''),
    condition: String(i.condition || ''),
    series_name: String(normSeries(i) || ''),
    qty: Math.max(1, Number(i.qty ?? i.quantity ?? 1) || 1)
  }));
}

function gatherOrderPayload() {
  const v = id => (document.getElementById(id)?.value || '').trim();
  const customer_name = v('fName');
  const email         = v('fEmail');
  const phone         = v('fPhone');
  const postal        = v('fPostal');
  const addr1         = v('fAddr1');
  const addr2         = v('fAddr2');
  const unit          = v('fUnit');
  const city          = v('fCity') || 'Singapore';
  const methodLabel   = v('fMethodLabel');
  const methodId      = v('fMethod');

  const cart  = getCart();
  const purch = cart.filter(isPurchasable);
  const savedShip = getSavedShippingFromCart();
  const shipFee   = Number(savedShip?.fee ?? 0);

  let subtotal = 0;
  const items = purch.map(i => {
    const qty  = Math.max(1, Number(i.qty ?? i.quantity ?? 1) || 1);
    const unit = Number(i.price ?? 0) || 0;
    const line = unit * qty;
    subtotal  += line;
    return { name: String(i.name || 'Item'), attrs: formatAttrs(i), qty, unit_price: unit, line_total: line };
  });

  const discCode = getSavedDiscountCode();
  const disc     = computeDiscount(subtotal, shipFee, discCode);
  const finalShip= Number(disc.ship || 0);
  const discount = Number(disc.amount || 0);

  const totalNum = Math.max(0, +(subtotal + finalShip - discount).toFixed(2));
  const totals = { subtotal, shipping: finalShip, discount, total: totalNum, discount_code: discCode || '', discount_label: disc.label || '' };

  return {
    order_id: currentOrderId || genOrderId(),
    created_at: formatDDMMYYYYHHMM(),
    customer_name, email, phone, postal, addr1, addr2, unit, city,
    shipping_method: methodLabel || methodId,
    remarks: escapeHtml((document.getElementById('orderNotes')?.value || '').trim()),
    items, totals
  };
}

function isValidShipForm(){
  const reqIds = ['fName','fEmail','fPhone','fPostal','fAddr1','fUnit','fCity','fMethod'];
  for (const id of reqIds){
    const el = document.getElementById(id);
    if (!el || !el.value || (el.validity && !el.validity.valid)) return false;
  }
  const agree = document.getElementById('disc1');
  const hasPurch = getCart().some(isPurchasable);
  const trap = document.getElementById('trapField');
  if (trap && trap.value.trim()) return false;
  return !!(agree && agree.checked && hasPurch);
}
function syncPayCta(){
  const cta = document.getElementById('btnPay');
  if (!cta) return;
  const ok = isValidShipForm();
  cta.toggleAttribute('disabled', !ok);
  cta.classList.add('show');
  cta.title = ok ? '' : 'Add at least one available item to proceed.';
}

/* ========= Init ========= */
function init(){
  applySavedShippingToForm();
  renderSummary();
  syncPayCta();

  document.querySelectorAll('#shipForm input, #shipForm select').forEach(el=>{
    const onInput = () => { setTouched(el); markValidity(el); renderSummary(); syncPayCta(); renderErrors(); };
    const onChange = onInput;
    const onBlur = () => { setTouched(el); markValidity(el); renderErrors(); };
    el.addEventListener('input', onInput);
    el.addEventListener('change', onChange);
    el.addEventListener('blur', onBlur);
  });
  document.getElementById('fAddr1')?.setAttribute('readonly','');

  document.getElementById('btnPay')?.addEventListener('click', async (e) => {
    const btn = e.currentTarget;
    if (isModalOpen) return;
    btn.disabled = true; btn.textContent = "Loading payment screen"; btn.classList.add("waiting");
    try { await openQr(); }
    finally {
      if (!isModalOpen) {
        btn.disabled = false; btn.textContent = "Make Payment"; btn.classList.remove("waiting");
      }
    }
  });

  document.getElementById('qrClose')?.addEventListener('click', confirmAbortAndExit);
  document.getElementById('qrCancel')?.addEventListener('click', confirmAbortAndExit);

  document.querySelector('#qrModal .qr-backdrop')?.addEventListener('click', (e)=>{
    if (e.target.classList.contains('qr-backdrop')) confirmAbortAndExit();
  });

  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape' && !document.getElementById('qrModal').hidden){
      e.preventDefault();
      confirmAbortAndExit();
    }
  });

  const paidBtn = document.getElementById('qrPaid');
  const proof   = document.getElementById('proofFile');
  if (paidBtn && proof){
    paidBtn.disabled = true;
    proof.addEventListener('change', () => {
      paidBtn.disabled = !proof.files.length;
      const statusEl = document.getElementById('uploadStatus');
      statusEl.textContent = proof.files.length ? 'Ready to upload.' : '';
      statusEl.classList.remove('ok','err');
    });
  }

  window.addEventListener('pointerdown', () => {
    const a = document.getElementById('uploadSfx');
    if (a && a.readyState < 2) { try { a.load(); } catch{} }
  }, { once:true });
}

const sleep = (ms) => new Promise(r => setTimeout(r, ms));

document.getElementById('qrPaid')?.addEventListener('click', async (e) => {
  e.preventDefault();
  playUploadSfx();
  const ok = await uploadPaymentProofJSON();
  if (!ok) return;

  const d = getDraft();
  if (d?.holdId && d?.holdToken && (currentOrderId || d.orderId)) {
    try {
      const conf = await apiConfirm(d.holdId, d.holdToken, currentOrderId || d.orderId);
      if (!conf?.ok) console.warn('Inventory confirm failed:', conf?.error);
    } catch (e) { console.warn('Inventory confirm error:', e); }
  }

  try {
    const orderPayload = gatherOrderPayload();
    orderPayload.order_id = currentOrderId || orderPayload.order_id;
    if (lastProofUrl) orderPayload.proof_url = lastProofUrl;

    let pdfResOk = false;
    try {
      const pdfRes = await fetch(EMAIL_PDF_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(orderPayload) });
      if ((pdfRes.headers.get('content-type') || '').includes('application/json')) {
        const data = await pdfRes.json(); pdfResOk = !!(data && data.ok);
      } else { pdfResOk = pdfRes.ok; }
    } catch (_) {}
    if (!pdfResOk) {
      await fetch(EMAIL_PDF_API, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(orderPayload), mode: 'no-cors' });
      pdfResOk = true;
    }
    if (!pdfResOk) console.warn('PDF emailer did not confirm success, but continuing UX flow.');
  } catch (err) {
    console.error('PDF emailer error:', err);
  }

  clearLocalCartHard();
  if (countdown) { clearInterval(countdown); countdown = null; }
  endTime = 0;

  const statusEl = document.getElementById('uploadStatus');
  statusEl.classList.add('ok'); statusEl.classList.remove('err');
  statusEl.textContent = 'We will verify and send order confirmation soon.'; 
  await sleep(1500);                                                      
  for (let s = 3; s >= 1; s--) { statusEl.textContent = `Redirecting in ${s}â€¦`; await sleep(1000); }
  clearDraft();
  suppressUnloadOnce = true; isRedirecting = true; isModalOpen = false;
  window.removeEventListener('beforeunload', beforeUnloadHandler);
  window.location.replace('teststore.html');
  return;
});

const EMAIL_DOMAINS = ['gmail.com','yahoo.com','outlook.com','hotmail.com','live.com','icloud.com'];
function validateEmailDomain(value){
  const v = String(value || '').trim().toLowerCase();
  if (!v) return { ok:false, msg:'Email is required' };
  if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(v)) { return { ok:false, msg:'Enter a valid email address' }; }
  const domain = v.split('@')[1] || '';
  if (!EMAIL_DOMAINS.includes(domain)) {
    return { ok:false, msg:`Please use a common email domain (e.g. ${EMAIL_DOMAINS.slice(0,3).join(', ')})` };
  }
  return { ok:true, msg:'' };
}

const postalEl = document.getElementById('fPostal');
const postalHintEl = document.getElementById('postalHint');
const hint = (msg, state='info') => {
  if (postalHintEl) postalHintEl.textContent = msg || '';
  if (postalEl) { postalEl.dataset.state = state; postalEl.title = msg || ''; }
};
let lastPostalReqId = 0;

async function tryLookupPostal(){
  if (!postalEl) return;
  const val = postalEl.value.replace(/\D/g,'');
  if (val.length !== 6) { hint(''); postalEl.dataset.state = ''; return; }
  const myId = ++lastPostalReqId;
  hint('Looking upâ€¦');
  try {
    const addr = await fetchSGAddressByPostal(val);
    if (myId !== lastPostalReqId) return;
    fillAddressFields(addr);
    hint('Address found âœ“','ok');
  } catch(err){
    if (myId !== lastPostalReqId) return;
    const m = String(err?.message || '');
    if (m === 'INPUT_6_DIGITS')        hint('Please enter a 6-digit postal code.','err');
    else if (m === 'LOOKUP_NET' || m === 'LOOKUP_HTTP') hint('Lookup error. Please check your connection and try again.','err');
    else if (m === 'POSTAL_NOT_FOUND') hint('Postal not found. Please key address manually.','err');
    else                               hint('Lookup error. Please try again.','err');
    console.warn('[Postal lookup failed]', err);
  }
}

const phoneEl = document.getElementById('fPhone');
phoneEl?.addEventListener('input', () => {
  phoneEl.value = phoneEl.value.replace(/\D/g,'').slice(0,8);
  const ok = /^[89]\d{7}$/.test(phoneEl.value);
  setTouched(phoneEl);
  phoneEl.setCustomValidity(ok || phoneEl.value.length === 0 ? '' : 'Phone must be 8 digits and start with 8 or 9.');
  markValidity(phoneEl);
  renderErrors(); syncPayCta();
});
phoneEl?.addEventListener('blur', () => {
  const ok = /^[89]\d{7}$/.test(phoneEl.value);
  setTouched(phoneEl);
  phoneEl.setCustomValidity(ok ? '' : 'Phone must be 8 digits and start with 8 or 9.');
  markValidity(phoneEl);
  renderErrors();
});

const unitEl = document.getElementById('fUnit');
unitEl?.addEventListener('input', () => {
  unitEl.value = unitEl.value.replace(/[^0-9A-Za-z-]/g,'').slice(0,8);
  const ok = /^[0-9A-Za-z-]{1,8}$/.test(unitEl.value);
  setTouched(unitEl);
  unitEl.setCustomValidity(ok || unitEl.value.length === 0 ? '' : 'Use letters/numbers/dash only, max 8.');
  markValidity(unitEl);
  renderErrors(); syncPayCta();
});

if (typeof QRCode === 'undefined') {
  console.warn('qrcode.min.js did not load. Check the script path.');
}

postalEl?.addEventListener('input', () => {
  const digits = postalEl.value.replace(/\D/g,'');
  if (digits.length === 6) tryLookupPostal(true);
});
postalEl?.addEventListener('input', debounce(() => {
  const digits = postalEl.value.replace(/\D/g,'');
  if (digits.length === 6) return;
  tryLookupPostal();
}, 400));
postalEl?.addEventListener('blur', () => tryLookupPostal());

function wireDiscountUI(){
  const input = document.getElementById('discCode');
  const apply = document.getElementById('discApply');

  // If the discount UI isn't in the DOM, just skip quietly.
  if (!input || !apply) {
    console.warn('[wireDiscountUI] discount inputs not found â€” skipping.');
    return;
  }

  // Preload saved code into the box (nice UX)
  const saved = (getSavedDiscountCode() || '').toLowerCase();
  if (saved) input.value = saved;
  if (saved && DISCOUNT_RULES[saved]) apply.textContent = 'Remove';

  // Toggle Apply/Remove in one place
  apply.addEventListener('click', () => {
    const mode = (apply.textContent || '').trim().toLowerCase();

    // Remove current code
    if (mode === 'remove') {
      setSavedDiscountCode('');
      input.value = '';
      apply.textContent = 'Apply';
      renderSummary();
      syncPayCta();
      return;
    }

    // Apply entered code
    const entered = (input.value || '').trim().toLowerCase();
    if (!entered) {
      setSavedDiscountCode('');
      renderSummary();
      syncPayCta();
      return;
    }

    if (!DISCOUNT_RULES[entered]) {
      alert('Invalid or expired code. Please check and try again.');
      return;
    }

    // (Optional) minimum subtotal check now
    const subtotalNow = getCart().filter(isPurchasable).reduce((s,i)=>{
      const q = Math.max(1, Number(i.qty ?? i.quantity ?? 1) || 1);
      const u = Number(i.price ?? 0) || 0;
      return s + (u*q);
    }, 0);
    const min = Number(DISCOUNT_RULES[entered].minSubtotal || 0);
    if (min > 0 && subtotalNow < min) {
      alert(`This code requires a minimum subtotal of ${fmt(min)}.`);
      return;
    }

    setSavedDiscountCode(entered);
    apply.textContent = 'Remove';
    renderSummary();
    syncPayCta();
  });

  // Enter key applies/removes
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      apply.click();
    }
  });
}

function beforeUnloadHandler(e){
  if (isRedirecting || suppressUnloadOnce) { suppressUnloadOnce = false; return; }
  if (isModalOpen || isUploading) { e.preventDefault(); e.returnValue = ''; }
}
window.addEventListener('beforeunload', beforeUnloadHandler);

window.addEventListener('popstate', () => {
  if (isRedirecting) return;
  if (isModalOpen) {
    try { history.pushState({qr:true}, '', location.href); } catch {}
    if (!document.getElementById('qrModal').hidden) { confirmAbortAndExit(); }
  }
});

window.addEventListener('storage', async (e) => {
  if (e.key !== DRAFT_KEY) return;
  const d = getDraft();
  if (!d || isExpired(d)) {
    if (countdown) { clearInterval(countdown); countdown = null; }
    if (d?.holdId && d?.holdToken) { try { await apiCancel(d.holdId, d.holdToken, 'EXTERNAL_CLEAR'); } catch {} }
    closeQr(); return;
  }
  currentOrderId = d.orderId || currentOrderId;
  if (d.qrPayload) renderQr(d.qrPayload);
  endTime = d.endTime;
  if (countdown) { clearInterval(countdown); }
  tick(); countdown = setInterval(tick, 1000);
  document.getElementById('qrModal').hidden = false;
  isModalOpen = true;
});

document.addEventListener('keydown', (e) => {
  const isRefreshKey = (e.key === 'F5') || ((e.key?.toLowerCase?.() === 'r') && (e.ctrlKey || e.metaKey));
  if (!isRefreshKey) return;
  if (isModalOpen || isUploading) { e.preventDefault(); alert('Payment in progress â€” please do not refresh or close this page.'); return; }
  e.preventDefault();
  const ok = window.confirm('Return to the store? Unsaved checkout info will be lost.');
  if (ok) window.location.href = 'teststore.html';
});

window.addEventListener('DOMContentLoaded', async () => {
  const d = getDraft();
  if (!d) return;
  if (isExpired(d)) { notifyExpire(d.orderId, 'TIMEOUT'); clearDraft(); return; }
  const currentHash  = cartFingerprint();
  const currentTotal = totalCentsFromText(document.getElementById('sumTotal')?.textContent || '');
  if (d.cartHash !== currentHash || d.totalCents !== currentTotal) {
    const ok = window.confirm(`Your cart changed from ${d.amountText} to ${document.getElementById('sumTotal')?.textContent || ''}.\nGenerate a new QR for the updated amount?`);
    if (ok) { try { await notifyExpire(d.orderId, 'CART_CHANGED'); } catch {} clearDraft(); return; }
  }
  currentOrderId = d.orderId || currentOrderId;
  if (d.qrPayload) renderQr(d.qrPayload);
  endTime = d.endTime;
  document.getElementById('qrPayTo').textContent   = d.payToLabel || 'PayNow';
  document.getElementById('qrAmount').textContent  = d.amountText || document.getElementById('sumTotal')?.textContent || '$0.00';
  document.getElementById('qrOrderId').textContent = d.orderId || 'â€”';
  tick();
  if (countdown) clearInterval(countdown);
  countdown = setInterval(tick, 1000);
  document.getElementById('qrModal').hidden = false;
  isModalOpen = true;
});

document.addEventListener('DOMContentLoaded', async () => {
  await loadDiscountRules();
  init();
  wireDiscountUI();
});
</script>
